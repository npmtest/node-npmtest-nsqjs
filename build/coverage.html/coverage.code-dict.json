{"/home/travis/build/npmtest/node-npmtest-nsqjs/test.js":"/* istanbul instrument in package npmtest_nsqjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nsqjs/lib.npmtest_nsqjs.js":"/* istanbul instrument in package npmtest_nsqjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nsqjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nsqjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nsqjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nsqjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nsqjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nsqjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nsqjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nsqjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nsqjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nsqjs.__dirname + '/lib.npmtest_nsqjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/nsq.js":"// Generated by CoffeeScript 1.12.5\nvar NSQDConnection, WriterNSQDConnection, ref;\n\nref = require('./nsqdconnection'), NSQDConnection = ref.NSQDConnection, WriterNSQDConnection = ref.WriterNSQDConnection;\n\nmodule.exports = {\n  Reader: require('./reader'),\n  Writer: require('./writer'),\n  NSQDConnection: NSQDConnection,\n  WriterNSQDConnection: WriterNSQDConnection\n};\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/nsqdconnection.js":"// Generated by CoffeeScript 1.12.5\nvar ConnectionConfig, ConnectionState, Debug, EventEmitter, FrameBuffer, Message, NSQDConnection, NodeState, SnappyStream, UnsnappyStream, WriterConnectionState, WriterNSQDConnection, _, fs, net, os, ref, tls, version, wire, zlib,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\nDebug = require('debug');\n\nnet = require('net');\n\nos = require('os');\n\ntls = require('tls');\n\nzlib = require('zlib');\n\nfs = require('fs');\n\nEventEmitter = require('events').EventEmitter;\n\nref = require('snappystream'), SnappyStream = ref.SnappyStream, UnsnappyStream = ref.UnsnappyStream;\n\n_ = require('underscore');\n\nNodeState = require('node-state');\n\nConnectionConfig = require('./config').ConnectionConfig;\n\nFrameBuffer = require('./framebuffer');\n\nMessage = require('./message');\n\nwire = require('./wire');\n\nversion = require('./version');\n\n\n/*\nNSQDConnection is a reader connection to a nsqd instance. It manages all\naspects of the nsqd connection with the exception of the RDY count which\nneeds to be managed across all nsqd connections for a given topic / channel\npair.\n\nThis shouldn't be used directly. Use a Reader instead.\n\nUsage:\n\nc = new NSQDConnection '127.0.0.1', 4150, 'test', 'default', 60, 30\n\nc.on NSQDConnection.MESSAGE, (msg) ->\n  console.log \"Callback [message]: #{msg.attempts}, #{msg.body.toString()}\"\n  console.log \"Timeout of message is #{msg.timeUntilTimeout()}\"\n  setTimeout (-> console.log \"timeout = #{msg.timeUntilTimeout()}\"), 5000\n  msg.finish()\n\nc.on NSQDConnection.FINISHED, ->\n  c.setRdy 1\n\nc.on NSQDConnection.READY, ->\n  console.log \"Callback [ready]: Set RDY to 100\"\n  c.setRdy 10\n\nc.on NSQDConnection.CLOSED, ->\n  console.log \"Callback [closed]: Lost connection to nsqd\"\n\nc.on NSQDConnection.ERROR, (err) ->\n  console.log \"Callback [error]: #{err}\"\n\nc.on NSQDConnection.BACKOFF, ->\n  console.log \"Callback [backoff]: RDY 0\"\n  c.setRdy 0\n  setTimeout (-> c.setRdy 100; console.log 'RDY 100'), 10 * 1000\n\nc.connect()\n */\n\nNSQDConnection = (function(superClass) {\n  extend(NSQDConnection, superClass);\n\n  NSQDConnection.BACKOFF = 'backoff';\n\n  NSQDConnection.CONNECTED = 'connected';\n\n  NSQDConnection.CLOSED = 'closed';\n\n  NSQDConnection.CONNECTION_ERROR = 'connection_error';\n\n  NSQDConnection.ERROR = 'error';\n\n  NSQDConnection.FINISHED = 'finished';\n\n  NSQDConnection.MESSAGE = 'message';\n\n  NSQDConnection.REQUEUED = 'requeued';\n\n  NSQDConnection.READY = 'ready';\n\n  function NSQDConnection(nsqdHost1, nsqdPort1, topic1, channel, options) {\n    var connId;\n    this.nsqdHost = nsqdHost1;\n    this.nsqdPort = nsqdPort1;\n    this.topic = topic1;\n    this.channel = channel;\n    if (options == null) {\n      options = {};\n    }\n    NSQDConnection.__super__.constructor.apply(this, arguments);\n    connId = this.id().replace(':', '/');\n    this.debug = Debug(\"nsqjs:reader:\" + this.topic + \"/\" + this.channel + \":conn:\" + connId);\n    this.config = new ConnectionConfig(options);\n    this.config.validate();\n    this.frameBuffer = new FrameBuffer();\n    this.statemachine = this.connectionState();\n    this.maxRdyCount = 0;\n    this.msgTimeout = 0;\n    this.maxMsgTimeout = 0;\n    this.nsqdVersion = null;\n    this.lastMessageTimestamp = null;\n    this.lastReceivedTimestamp = null;\n    this.conn = null;\n    this.identifyTimeoutId = null;\n    this.messageCallbacks = [];\n  }\n\n  NSQDConnection.prototype.id = function() {\n    return this.nsqdHost + \":\" + this.nsqdPort;\n  };\n\n  NSQDConnection.prototype.connectionState = function() {\n    return this.statemachine || new ConnectionState(this);\n  };\n\n  NSQDConnection.prototype.connect = function() {\n    this.statemachine.raise('connecting');\n    return process.nextTick((function(_this) {\n      return function() {\n        _this.conn = net.connect(_this.nsqdPort, _this.nsqdHost, function() {\n          _this.statemachine.raise('connected');\n          _this.emit(NSQDConnection.CONNECTED);\n          return _this.identifyTimeoutId = setTimeout(_this.identifyTimeout.bind(_this), 5000);\n        });\n        return _this.registerStreamListeners(_this.conn);\n      };\n    })(this));\n  };\n\n  NSQDConnection.prototype.registerStreamListeners = function(conn) {\n    conn.on('data', (function(_this) {\n      return function(data) {\n        return _this.receiveRawData(data);\n      };\n    })(this));\n    conn.on('error', (function(_this) {\n      return function(err) {\n        _this.statemachine.goto('CLOSED');\n        return _this.emit('connection_error', err);\n      };\n    })(this));\n    return conn.on('close', (function(_this) {\n      return function(err) {\n        return _this.statemachine.raise('close');\n      };\n    })(this));\n  };\n\n  NSQDConnection.prototype.startTLS = function(callback) {\n    var event, i, len, options, ref1, tlsConn;\n    ref1 = ['data', 'error', 'close'];\n    for (i = 0, len = ref1.length; i < len; i++) {\n      event = ref1[i];\n      this.conn.removeAllListeners(event);\n    }\n    options = {\n      socket: this.conn,\n      rejectUnauthorized: this.config.tlsVerification\n    };\n    tlsConn = tls.connect(options, (function(_this) {\n      return function() {\n        _this.conn = tlsConn;\n        return typeof callback === \"function\" ? callback() : void 0;\n      };\n    })(this));\n    return this.registerStreamListeners(tlsConn);\n  };\n\n  NSQDConnection.prototype.startDeflate = function(level) {\n    this.inflater = zlib.createInflateRaw({\n      flush: zlib.Z_SYNC_FLUSH\n    });\n    this.deflater = zlib.createDeflateRaw({\n      level: level,\n      flush: zlib.Z_SYNC_FLUSH\n    });\n    return this.reconsumeFrameBuffer();\n  };\n\n  NSQDConnection.prototype.startSnappy = function() {\n    this.inflater = new UnsnappyStream();\n    this.deflater = new SnappyStream();\n    return this.reconsumeFrameBuffer();\n  };\n\n  NSQDConnection.prototype.reconsumeFrameBuffer = function() {\n    var data;\n    if (this.frameBuffer.buffer && this.frameBuffer.buffer.length) {\n      data = this.frameBuffer.buffer;\n      delete this.frameBuffer.buffer;\n      return this.receiveRawData(data);\n    }\n  };\n\n  NSQDConnection.prototype.setRdy = function(rdyCount) {\n    return this.statemachine.raise('ready', rdyCount);\n  };\n\n  NSQDConnection.prototype.receiveRawData = function(data) {\n    if (!this.inflater) {\n      return this.receiveData(data);\n    } else {\n      return this.inflater.write(data, (function(_this) {\n        return function() {\n          var uncompressedData;\n          uncompressedData = _this.inflater.read();\n          if (uncompressedData) {\n            return _this.receiveData(uncompressedData);\n          }\n        };\n      })(this));\n    }\n  };\n\n  NSQDConnection.prototype.receiveData = function(data) {\n    var frame, frameId, payload, results;\n    this.lastReceivedTimestamp = Date.now();\n    this.frameBuffer.consume(data);\n    results = [];\n    while (frame = this.frameBuffer.nextFrame()) {\n      frameId = frame[0], payload = frame[1];\n      switch (frameId) {\n        case wire.FRAME_TYPE_RESPONSE:\n          results.push(this.statemachine.raise('response', payload));\n          break;\n        case wire.FRAME_TYPE_ERROR:\n          results.push(this.statemachine.goto('ERROR', new Error(payload.toString())));\n          break;\n        case wire.FRAME_TYPE_MESSAGE:\n          this.lastMessageTimestamp = this.lastReceivedTimestamp;\n          results.push(this.statemachine.raise('consumeMessage', this.createMessage(payload)));\n          break;\n        default:\n          results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  NSQDConnection.prototype.identify = function() {\n    var i, identify, key, len, longName, removableKeys, shortName;\n    longName = os.hostname();\n    shortName = longName.split('.')[0];\n    identify = {\n      client_id: this.config.clientId || shortName,\n      deflate: this.config.deflate,\n      deflate_level: this.config.deflateLevel,\n      feature_negotiation: true,\n      heartbeat_interval: this.config.heartbeatInterval * 1000,\n      long_id: longName,\n      msg_timeout: this.config.messageTimeout,\n      output_buffer_size: this.config.outputBufferSize,\n      output_buffer_timeout: this.config.outputBufferTimeout,\n      sample_rate: this.config.sampleRate,\n      short_id: shortName,\n      snappy: this.config.snappy,\n      tls_v1: this.config.tls,\n      user_agent: \"nsqjs/\" + version\n    };\n    removableKeys = ['msg_timeout', 'output_buffer_size', 'output_buffer_timeout', 'sample_rate'];\n    for (i = 0, len = removableKeys.length; i < len; i++) {\n      key = removableKeys[i];\n      if (identify[key] === null) {\n        delete identify[key];\n      }\n    }\n    return identify;\n  };\n\n  NSQDConnection.prototype.identifyTimeout = function() {\n    return this.statemachine.goto('ERROR', new Error('Timed out identifying with nsqd'));\n  };\n\n  NSQDConnection.prototype.clearIdentifyTimeout = function() {\n    clearTimeout(this.identifyTimeoutId);\n    return this.identifyTimeoutId = null;\n  };\n\n  NSQDConnection.prototype.createMessage = function(msgPayload) {\n    var msg, msgComponents;\n    msgComponents = wire.unpackMessage(msgPayload);\n    msg = (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(Message, slice.call(msgComponents).concat([this.config.requeueDelay], [this.msgTimeout], [this.maxMsgTimeout]), function(){});\n    this.debug(\"Received message [\" + msg.id + \"] [attempts: \" + msg.attempts + \"]\");\n    msg.on(Message.RESPOND, (function(_this) {\n      return function(responseType, wireData) {\n        _this.write(wireData);\n        if (responseType === Message.FINISH) {\n          _this.debug(\"Finished message [\" + msg.id + \"] [timedout=\" + (msg.timedout === true) + \", elapsed=\" + (Date.now() - msg.receivedOn) + \"ms, touch_count=\" + msg.touchCount + \"]\");\n          return _this.emit(NSQDConnection.FINISHED);\n        } else if (responseType === Message.REQUEUE) {\n          _this.debug(\"Requeued message [\" + msg.id + \"]\");\n          return _this.emit(NSQDConnection.REQUEUED);\n        }\n      };\n    })(this));\n    msg.on(Message.BACKOFF, (function(_this) {\n      return function() {\n        return _this.emit(NSQDConnection.BACKOFF);\n      };\n    })(this));\n    return msg;\n  };\n\n  NSQDConnection.prototype.write = function(data) {\n    if (this.deflater) {\n      return this.deflater.write(data, (function(_this) {\n        return function() {\n          return _this.conn.write(_this.deflater.read());\n        };\n      })(this));\n    } else {\n      return this.conn.write(data);\n    }\n  };\n\n  NSQDConnection.prototype.destroy = function() {\n    return this.conn.destroy();\n  };\n\n  return NSQDConnection;\n\n})(EventEmitter);\n\nConnectionState = (function(superClass) {\n  extend(ConnectionState, superClass);\n\n  function ConnectionState(conn1) {\n    this.conn = conn1;\n    ConnectionState.__super__.constructor.call(this, {\n      autostart: true,\n      initial_state: 'INIT',\n      sync_goto: true\n    });\n    this.identifyResponse = null;\n  }\n\n  ConnectionState.prototype.log = function(message) {\n    if (this.current_state_name !== 'INIT') {\n      this.conn.debug(\"\" + this.current_state_name);\n    }\n    if (message) {\n      return this.conn.debug(message);\n    }\n  };\n\n  ConnectionState.prototype.afterIdentify = function() {\n    return 'SUBSCRIBE';\n  };\n\n  ConnectionState.prototype.states = {\n    INIT: {\n      connecting: function() {\n        return this.goto('CONNECTING');\n      }\n    },\n    CONNECTING: {\n      connected: function() {\n        return this.goto('CONNECTED');\n      }\n    },\n    CONNECTED: {\n      Enter: function() {\n        return this.goto('SEND_MAGIC_IDENTIFIER');\n      }\n    },\n    SEND_MAGIC_IDENTIFIER: {\n      Enter: function() {\n        this.conn.write(wire.MAGIC_V2);\n        return this.goto('IDENTIFY');\n      }\n    },\n    IDENTIFY: {\n      Enter: function() {\n        var identify;\n        identify = this.conn.identify();\n        this.conn.debug(identify);\n        this.conn.write(wire.identify(identify));\n        return this.goto('IDENTIFY_RESPONSE');\n      }\n    },\n    IDENTIFY_RESPONSE: {\n      response: function(data) {\n        if (data.toString() === 'OK') {\n          data = JSON.stringify({\n            max_rdy_count: 2500,\n            max_msg_timeout: 15 * 60 * 1000,\n            msg_timeout: 60 * 1000\n          });\n        }\n        this.identifyResponse = JSON.parse(data);\n        this.conn.debug(this.identifyResponse);\n        this.conn.maxRdyCount = this.identifyResponse.max_rdy_count;\n        this.conn.maxMsgTimeout = this.identifyResponse.max_msg_timeout;\n        this.conn.msgTimeout = this.identifyResponse.msg_timeout;\n        this.conn.nsqdVersion = this.identifyResponse.version;\n        this.conn.clearIdentifyTimeout();\n        if (this.identifyResponse.tls_v1) {\n          return this.goto('TLS_START');\n        }\n        return this.goto('IDENTIFY_COMPRESSION_CHECK');\n      }\n    },\n    IDENTIFY_COMPRESSION_CHECK: {\n      Enter: function() {\n        var deflate, ref1, snappy;\n        ref1 = this.identifyResponse, deflate = ref1.deflate, snappy = ref1.snappy;\n        if (deflate) {\n          return this.goto('DEFLATE_START', this.identifyResponse.deflate_level);\n        }\n        if (snappy) {\n          return this.goto('SNAPPY_START');\n        }\n        return this.goto('AUTH');\n      }\n    },\n    TLS_START: {\n      Enter: function() {\n        this.conn.startTLS();\n        return this.goto('TLS_RESPONSE');\n      }\n    },\n    TLS_RESPONSE: {\n      response: function(data) {\n        if (data.toString() === 'OK') {\n          return this.goto('IDENTIFY_COMPRESSION_CHECK');\n        } else {\n          return this.goto('ERROR', new Error('TLS negotiate error with nsqd'));\n        }\n      }\n    },\n    DEFLATE_START: {\n      Enter: function(level) {\n        this.conn.startDeflate(level);\n        return this.goto('COMPRESSION_RESPONSE');\n      }\n    },\n    SNAPPY_START: {\n      Enter: function() {\n        this.conn.startSnappy();\n        return this.goto('COMPRESSION_RESPONSE');\n      }\n    },\n    COMPRESSION_RESPONSE: {\n      response: function(data) {\n        if (data.toString() === 'OK') {\n          return this.goto('AUTH');\n        } else {\n          return this.goto('ERROR', new Error('Bad response when enabling compression'));\n        }\n      }\n    },\n    AUTH: {\n      Enter: function() {\n        if (!this.conn.config.authSecret) {\n          return this.goto(this.afterIdentify());\n        }\n        this.conn.write(wire.auth(this.conn.config.authSecret));\n        return this.goto('AUTH_RESPONSE');\n      }\n    },\n    AUTH_RESPONSE: {\n      response: function(data) {\n        this.conn.auth = JSON.parse(data);\n        return this.goto(this.afterIdentify());\n      }\n    },\n    SUBSCRIBE: {\n      Enter: function() {\n        this.conn.write(wire.subscribe(this.conn.topic, this.conn.channel));\n        return this.goto('SUBSCRIBE_RESPONSE');\n      }\n    },\n    SUBSCRIBE_RESPONSE: {\n      response: function(data) {\n        if (data.toString() === 'OK') {\n          this.goto('READY_RECV');\n          return this.conn.emit(NSQDConnection.READY);\n        }\n      }\n    },\n    READY_RECV: {\n      consumeMessage: function(msg) {\n        return this.conn.emit(NSQDConnection.MESSAGE, msg);\n      },\n      response: function(data) {\n        if (data.toString() === '_heartbeat_') {\n          return this.conn.write(wire.nop());\n        }\n      },\n      ready: function(rdyCount) {\n        if (rdyCount > this.conn.maxRdyCount) {\n          rdyCount = this.conn.maxRdyCount;\n        }\n        return this.conn.write(wire.ready(rdyCount));\n      },\n      close: function() {\n        return this.goto('CLOSED');\n      }\n    },\n    READY_SEND: {\n      Enter: function() {\n        return this.conn.emit(NSQDConnection.READY);\n      },\n      produceMessages: function(data) {\n        var callback, msgs, topic;\n        topic = data[0], msgs = data[1], callback = data[2];\n        this.conn.messageCallbacks.push(callback);\n        if (!_.isArray(msgs)) {\n          throw new Error('Expect an array of messages to produceMessages');\n        }\n        if (msgs.length === 1) {\n          return this.conn.write(wire.pub(topic, msgs[0]));\n        } else {\n          return this.conn.write(wire.mpub(topic, msgs));\n        }\n      },\n      response: function(data) {\n        var cb;\n        switch (data.toString()) {\n          case 'OK':\n            cb = this.conn.messageCallbacks.shift();\n            return typeof cb === \"function\" ? cb(null) : void 0;\n          case '_heartbeat_':\n            return this.conn.write(wire.nop());\n        }\n      },\n      close: function() {\n        return this.goto('CLOSED');\n      }\n    },\n    ERROR: {\n      Enter: function(err) {\n        var cb, errorCode, ref1;\n        cb = this.conn.messageCallbacks.shift();\n        if (typeof cb === \"function\") {\n          cb(err);\n        }\n        this.conn.emit(NSQDConnection.ERROR, err);\n        if (!_.isString(err)) {\n          err = err.toString();\n        }\n        errorCode = (ref1 = err.split(/\\s+/)) != null ? ref1[1] : void 0;\n        if (errorCode === 'E_REQ_FAILED' || errorCode === 'E_FIN_FAILED' || errorCode === 'E_TOUCH_FAILED') {\n          return this.goto('READY_RECV');\n        } else {\n          return this.goto('CLOSED');\n        }\n      },\n      close: function() {\n        return this.goto('CLOSED');\n      }\n    },\n    CLOSED: {\n      Enter: function() {\n        var cb, err, i, len, ref1;\n        if (!this.conn) {\n          return;\n        }\n        err = new Error('nsqd connection closed');\n        ref1 = this.conn.messageCallbacks;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          cb = ref1[i];\n          if (typeof cb === \"function\") {\n            cb(err);\n          }\n        }\n        this.conn.messageCallbacks = [];\n        this.disable();\n        this.conn.destroy();\n        this.conn.emit(NSQDConnection.CLOSED);\n        return delete this.conn;\n      },\n      close: function() {}\n    }\n  };\n\n  ConnectionState.prototype.transitions = {\n    '*': {\n      '*': function(data, callback) {\n        this.log();\n        return callback(data);\n      },\n      CONNECTED: function(data, callback) {\n        this.log();\n        return callback(data);\n      },\n      ERROR: function(err, callback) {\n        this.log(\"\" + err);\n        return callback(err);\n      }\n    }\n  };\n\n  return ConnectionState;\n\n})(NodeState);\n\n\n/*\nc = new NSQDConnectionWriter '127.0.0.1', 4150, 30\nc.connect()\n\nc.on NSQDConnectionWriter.CLOSED, ->\n  console.log \"Callback [closed]: Lost connection to nsqd\"\n\nc.on NSQDConnectionWriter.ERROR, (err) ->\n  console.log \"Callback [error]: #{err}\"\n\nc.on NSQDConnectionWriter.READY, ->\n  c.produceMessages 'sample_topic', ['first message']\n  c.produceMessages 'sample_topic', ['second message', 'third message']\n  c.destroy()\n */\n\nWriterNSQDConnection = (function(superClass) {\n  extend(WriterNSQDConnection, superClass);\n\n  function WriterNSQDConnection(nsqdHost, nsqdPort, options) {\n    if (options == null) {\n      options = {};\n    }\n    WriterNSQDConnection.__super__.constructor.call(this, nsqdHost, nsqdPort, null, null, options);\n    this.debug = Debug(\"nsqjs:writer:conn:\" + nsqdHost + \"/\" + nsqdPort);\n  }\n\n  WriterNSQDConnection.prototype.connectionState = function() {\n    return this.statemachine || new WriterConnectionState(this);\n  };\n\n  WriterNSQDConnection.prototype.produceMessages = function(topic, msgs, callback) {\n    return this.statemachine.raise('produceMessages', [topic, msgs, callback]);\n  };\n\n  return WriterNSQDConnection;\n\n})(NSQDConnection);\n\nWriterConnectionState = (function(superClass) {\n  extend(WriterConnectionState, superClass);\n\n  function WriterConnectionState() {\n    return WriterConnectionState.__super__.constructor.apply(this, arguments);\n  }\n\n  WriterConnectionState.prototype.afterIdentify = function() {\n    return 'READY_SEND';\n  };\n\n  return WriterConnectionState;\n\n})(ConnectionState);\n\nmodule.exports = {\n  NSQDConnection: NSQDConnection,\n  ConnectionState: ConnectionState,\n  WriterNSQDConnection: WriterNSQDConnection,\n  WriterConnectionState: WriterConnectionState\n};\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/config.js":"// Generated by CoffeeScript 1.12.5\nvar ConnectionConfig, ReaderConfig, _, url,\n  slice = [].slice,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\n_ = require('underscore');\n\nurl = require('url');\n\nConnectionConfig = (function() {\n  var isBareAddress;\n\n  ConnectionConfig.DEFAULTS = {\n    authSecret: null,\n    clientId: null,\n    deflate: false,\n    deflateLevel: 6,\n    heartbeatInterval: 30,\n    maxInFlight: 1,\n    messageTimeout: null,\n    outputBufferSize: null,\n    outputBufferTimeout: null,\n    requeueDelay: 90,\n    sampleRate: null,\n    snappy: false,\n    tls: false,\n    tlsVerification: true\n  };\n\n  function ConnectionConfig(options) {\n    if (options == null) {\n      options = {};\n    }\n    options = _.chain(options).pick(_.keys(this.constructor.DEFAULTS)).defaults(this.constructor.DEFAULTS).value();\n    _.extend(this, options);\n  }\n\n  ConnectionConfig.prototype.isNonEmptyString = function(option, value) {\n    if (!(_.isString(value) && value.length > 0)) {\n      throw new Error(option + \" must be a non-empty string\");\n    }\n  };\n\n  ConnectionConfig.prototype.isNumber = function(option, value, lower, upper) {\n    if (upper == null) {\n      upper = null;\n    }\n    if (_.isNaN(value) || !_.isNumber(value)) {\n      throw new Error(option + \"(\" + value + \") is not a number\");\n    }\n    if (upper) {\n      if (!((lower <= value && value <= upper))) {\n        throw new Error(lower + \" <= \" + option + \"(\" + value + \") <= \" + upper);\n      }\n    } else {\n      if (!(lower <= value)) {\n        throw new Error(lower + \" <= \" + option + \"(\" + value + \")\");\n      }\n    }\n  };\n\n  ConnectionConfig.prototype.isNumberExclusive = function(option, value, lower, upper) {\n    if (upper == null) {\n      upper = null;\n    }\n    if (_.isNaN(value) || !_.isNumber(value)) {\n      throw new Error(option + \"(\" + value + \") is not a number\");\n    }\n    if (upper) {\n      if (!((lower < value && value < upper))) {\n        throw new Error(lower + \" < \" + option + \"(\" + value + \") < \" + upper);\n      }\n    } else {\n      if (!(lower < value)) {\n        throw new Error(lower + \" < \" + option + \"(\" + value + \")\");\n      }\n    }\n  };\n\n  ConnectionConfig.prototype.isBoolean = function(option, value) {\n    if (!_.isBoolean(value)) {\n      throw new Error(option + \" must be either true or false\");\n    }\n  };\n\n  isBareAddress = function(addr) {\n    var host, port, ref;\n    ref = addr.split(':'), host = ref[0], port = ref[1];\n    return host.length > 0 && port > 0;\n  };\n\n  ConnectionConfig.prototype.isBareAddresses = function(option, value) {\n    if (!(_.isArray(value) && _.every(value, isBareAddress))) {\n      throw new Error(option + \" must be a list of addresses 'host:port'\");\n    }\n  };\n\n  ConnectionConfig.prototype.isLookupdHTTPAddresses = function(option, value) {\n    var isAddr;\n    isAddr = function(addr) {\n      var parsedUrl, ref;\n      if (addr.indexOf('://') === -1) {\n        return isBareAddress(addr);\n      }\n      parsedUrl = url.parse(addr);\n      return ((ref = parsedUrl.protocol) === 'http:' || ref === 'https:') && !!parsedUrl.host;\n    };\n    if (!(_.isArray(value) && _.every(value, isAddr))) {\n      throw new Error(option + \" must be a list of addresses 'host:port' or HTTP/HTTPS URI\");\n    }\n  };\n\n  ConnectionConfig.prototype.conditions = function() {\n    return {\n      authSecret: [this.isNonEmptyString],\n      clientId: [this.isNonEmptyString],\n      deflate: [this.isBoolean],\n      deflateLevel: [this.isNumber, 0, 9],\n      heartbeatInterval: [this.isNumber, 1],\n      maxInFlight: [this.isNumber, 1],\n      messageTimeout: [this.isNumber, 1],\n      outputBufferSize: [this.isNumber, 64],\n      outputBufferTimeout: [this.isNumber, 1],\n      requeueDelay: [this.isNumber, 0],\n      sampleRate: [this.isNumber, 1, 99],\n      snappy: [this.isBoolean],\n      tls: [this.isBoolean],\n      tlsVerification: [this.isBoolean]\n    };\n  };\n\n  ConnectionConfig.prototype.validateOption = function(option, value) {\n    var args, fn, ref;\n    ref = this.conditions()[option], fn = ref[0], args = 2 <= ref.length ? slice.call(ref, 1) : [];\n    return fn.apply(null, [option, value].concat(slice.call(args)));\n  };\n\n  ConnectionConfig.prototype.validate = function() {\n    var keys, option, ref, value;\n    ref = this;\n    for (option in ref) {\n      value = ref[option];\n      if (_.isFunction(value)) {\n        continue;\n      }\n      if (_.isNull(value) && this.constructor.DEFAULTS[option] === null) {\n        continue;\n      }\n      keys = ['outputBufferSize', 'outputBufferTimeout'];\n      if (indexOf.call(keys, option) >= 0 && value === -1) {\n        continue;\n      }\n      this.validateOption(option, value);\n    }\n    if (this.snappy && this.deflate) {\n      throw new Error('Cannot use both deflate and snappy');\n    }\n  };\n\n  return ConnectionConfig;\n\n})();\n\nReaderConfig = (function(superClass) {\n  extend(ReaderConfig, superClass);\n\n  function ReaderConfig() {\n    return ReaderConfig.__super__.constructor.apply(this, arguments);\n  }\n\n  ReaderConfig.DEFAULTS = _.extend({}, ConnectionConfig.DEFAULTS, {\n    lookupdHTTPAddresses: [],\n    lookupdPollInterval: 60,\n    lookupdPollJitter: 0.3,\n    name: null,\n    nsqdTCPAddresses: [],\n    maxAttempts: 0,\n    maxBackoffDuration: 128\n  });\n\n  ReaderConfig.prototype.conditions = function() {\n    return _.extend({}, ReaderConfig.__super__.conditions.call(this), {\n      lookupdHTTPAddresses: [this.isLookupdHTTPAddresses],\n      lookupdPollInterval: [this.isNumber, 1],\n      lookupdPollJitter: [this.isNumberExclusive, 0, 1],\n      name: [this.isNonEmptyString],\n      nsqdTCPAddresses: [this.isBareAddresses],\n      maxAttempts: [this.isNumber, 0],\n      maxBackoffDuration: [this.isNumber, 0]\n    });\n  };\n\n  ReaderConfig.prototype.validate = function() {\n    var addresses, i, key, len, pass;\n    addresses = ['nsqdTCPAddresses', 'lookupdHTTPAddresses'];\n    for (i = 0, len = addresses.length; i < len; i++) {\n      key = addresses[i];\n      if (_.isString(this[key])) {\n        this[key] = [this[key]];\n      }\n    }\n    ReaderConfig.__super__.validate.apply(this, arguments);\n    pass = _.chain(addresses).map((function(_this) {\n      return function(key) {\n        return _this[key].length;\n      };\n    })(this)).any(_.identity).value();\n    if (!pass) {\n      throw new Error(\"Need to provide either \" + (addresses.join(' or ')));\n    }\n  };\n\n  return ReaderConfig;\n\n})(ConnectionConfig);\n\nmodule.exports = {\n  ConnectionConfig: ConnectionConfig,\n  ReaderConfig: ReaderConfig\n};\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/framebuffer.js":"// Generated by CoffeeScript 1.12.5\nvar FrameBuffer, _;\n\n_ = require('underscore');\n\nFrameBuffer = (function() {\n  function FrameBuffer() {}\n\n  FrameBuffer.prototype.consume = function(raw) {\n    return this.buffer = Buffer.concat(_.compact([this.buffer, raw]));\n  };\n\n  FrameBuffer.prototype.nextFrame = function() {\n    var frame, nextOffset;\n    if (!this.buffer) {\n      return;\n    }\n    if (!(this.frameSize(0) && this.frameSize(0) <= this.buffer.length)) {\n      return;\n    }\n    frame = this.pluckFrame();\n    nextOffset = this.nextOffset();\n    this.buffer = this.buffer.slice(nextOffset);\n    if (!this.buffer.length) {\n      delete this.buffer;\n    }\n    return frame;\n  };\n\n  FrameBuffer.prototype.pluckFrame = function(offset) {\n    var frame, frameId;\n    if (offset == null) {\n      offset = 0;\n    }\n    frame = this.buffer.slice(offset, offset + this.frameSize(offset));\n    frameId = frame.readInt32BE(4);\n    return [frameId, frame.slice(8)];\n  };\n\n  FrameBuffer.prototype.nextOffset = function(offset) {\n    var size;\n    if (offset == null) {\n      offset = 0;\n    }\n    size = this.frameSize(offset);\n    if (size) {\n      return offset + size;\n    }\n  };\n\n  FrameBuffer.prototype.frameSize = function(offset) {\n    if (!(this.buffer && this.buffer.length > 4)) {\n      return;\n    }\n    if (offset + 4 <= this.buffer.length) {\n      return 4 + this.buffer.readInt32BE(offset);\n    }\n  };\n\n  return FrameBuffer;\n\n})();\n\nmodule.exports = FrameBuffer;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/message.js":"// Generated by CoffeeScript 1.12.5\nvar EventEmitter, Message, _, wire,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\n_ = require('underscore');\n\nwire = require('./wire');\n\nEventEmitter = require('events').EventEmitter;\n\nMessage = (function(superClass) {\n  extend(Message, superClass);\n\n  Message.BACKOFF = 'backoff';\n\n  Message.RESPOND = 'respond';\n\n  Message.FINISH = 0;\n\n  Message.REQUEUE = 1;\n\n  Message.TOUCH = 2;\n\n  function Message(id, timestamp, attempts, body, requeueDelay, msgTimeout, maxMsgTimeout) {\n    var trackTimeout;\n    this.id = id;\n    this.timestamp = timestamp;\n    this.attempts = attempts;\n    this.body = body;\n    this.requeueDelay = requeueDelay;\n    this.msgTimeout = msgTimeout;\n    this.maxMsgTimeout = maxMsgTimeout;\n    this.hasResponded = false;\n    this.receivedOn = Date.now();\n    this.lastTouched = this.receivedOn;\n    this.touchCount = 0;\n    this.trackTimeoutId = null;\n    this.timedOut = false;\n    (trackTimeout = (function(_this) {\n      return function() {\n        var hard, soft;\n        if (_this.hasResponded) {\n          return;\n        }\n        soft = _this.timeUntilTimeout();\n        hard = _this.timeUntilTimeout(true);\n        _this.timedOut = !soft || !hard;\n        if (!_this.timedOut) {\n          clearTimeout(_this.trackTimeoutId);\n          return _this.trackTimeoutId = setTimeout(trackTimeout, Math.min(soft, hard));\n        }\n      };\n    })(this))();\n  }\n\n  Message.prototype.json = function() {\n    var err;\n    if (this.parsed == null) {\n      try {\n        this.parsed = JSON.parse(this.body);\n      } catch (error) {\n        err = error;\n        throw new Error(\"Invalid JSON in Message\");\n      }\n    }\n    return this.parsed;\n  };\n\n  Message.prototype.timeUntilTimeout = function(hard) {\n    var delta;\n    if (hard == null) {\n      hard = false;\n    }\n    if (this.hasResponded) {\n      return null;\n    }\n    delta = hard ? this.receivedOn + this.maxMsgTimeout - Date.now() : this.lastTouched + this.msgTimeout - Date.now();\n    if (delta > 0) {\n      return delta;\n    } else {\n      return null;\n    }\n  };\n\n  Message.prototype.finish = function() {\n    return this.respond(Message.FINISH, wire.finish(this.id));\n  };\n\n  Message.prototype.requeue = function(delay, backoff) {\n    if (delay == null) {\n      delay = this.requeueDelay;\n    }\n    if (backoff == null) {\n      backoff = true;\n    }\n    this.respond(Message.REQUEUE, wire.requeue(this.id, delay));\n    if (backoff) {\n      return this.emit(Message.BACKOFF);\n    }\n  };\n\n  Message.prototype.touch = function() {\n    this.touchCount += 1;\n    this.lastTouched = Date.now();\n    return this.respond(Message.TOUCH, wire.touch(this.id));\n  };\n\n  Message.prototype.respond = function(responseType, wireData) {\n    if (this.hasResponded) {\n      return;\n    }\n    return process.nextTick((function(_this) {\n      return function() {\n        if (responseType !== Message.TOUCH) {\n          _this.hasResponded = true;\n          clearTimeout(_this.trackTimeoutId);\n          _this.trackTimeoutId = null;\n        } else {\n          _this.lastTouched = Date.now();\n        }\n        return _this.emit(Message.RESPOND, responseType, wireData);\n      };\n    })(this));\n  };\n\n  return Message;\n\n})(EventEmitter);\n\nmodule.exports = Message;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/wire.js":"// Generated by CoffeeScript 1.12.5\nvar BigNumber, Int64, JSON_stringify, _, byteLength, command, validChannelName, validTopicName,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n_ = require('underscore');\n\nInt64 = require('node-int64');\n\nBigNumber = require('bignumber.js');\n\nexports.MAGIC_V2 = '  V2';\n\nexports.FRAME_TYPE_RESPONSE = 0;\n\nexports.FRAME_TYPE_ERROR = 1;\n\nexports.FRAME_TYPE_MESSAGE = 2;\n\nJSON_stringify = function(obj, emit_unicode) {\n  var json;\n  json = JSON.stringify(obj);\n  if (emit_unicode) {\n    return json;\n  } else {\n    return json.replace(/[\\u007f-\\uffff]/g, function(c) {\n      return '\\\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n    });\n  }\n};\n\nbyteLength = function(msg) {\n  if (_.isString(msg)) {\n    return Buffer.byteLength(msg);\n  } else {\n    return msg.length;\n  }\n};\n\nexports.unpackMessage = function(data) {\n  var attempts, body, id, timestamp;\n  timestamp = (new Int64(data, 0)).toOctetString();\n  timestamp = new BigNumber(timestamp, 16);\n  attempts = data.readInt16BE(8);\n  id = data.slice(10, 26).toString();\n  body = data.slice(26);\n  return [id, timestamp, attempts, body];\n};\n\ncommand = function(cmd, body) {\n  var buffers, header, lengthBuffer, parameters, parametersStr;\n  buffers = [];\n  parameters = _.toArray(arguments).slice(2);\n  if (parameters.length > 0) {\n    parameters.unshift('');\n  }\n  parametersStr = parameters.join(' ');\n  header = cmd + parametersStr + '\\n';\n  buffers.push(new Buffer(header));\n  if (body != null) {\n    lengthBuffer = new Buffer(4);\n    lengthBuffer.writeInt32BE(byteLength(body), 0);\n    buffers.push(lengthBuffer);\n    if (_.isString(body)) {\n      buffers.push(new Buffer(body));\n    } else {\n      buffers.push(body);\n    }\n  }\n  return Buffer.concat(buffers);\n};\n\nexports.subscribe = function(topic, channel) {\n  if (!validTopicName(topic)) {\n    throw new Error(\"Invalid topic: \" + topic);\n  }\n  if (!validChannelName(channel)) {\n    throw new Error(\"Invalid channel: \" + channel);\n  }\n  return command('SUB', null, topic, channel);\n};\n\nexports.identify = function(data) {\n  var unexpectedKeys, validIdentifyKeys;\n  validIdentifyKeys = ['client_id', 'deflate', 'deflate_level', 'feature_negotiation', 'heartbeat_interval', 'long_id', 'msg_timeout', 'output_buffer_size', 'output_buffer_timeout', 'sample_rate', 'short_id', 'snappy', 'tls_v1', 'user_agent'];\n  unexpectedKeys = _.filter(_.keys(data), function(k) {\n    return indexOf.call(validIdentifyKeys, k) < 0;\n  });\n  if (unexpectedKeys.length) {\n    throw new Error(\"Unexpected IDENTIFY keys: \" + unexpectedKeys);\n  }\n  return command('IDENTIFY', JSON_stringify(data));\n};\n\nexports.ready = function(count) {\n  if (!_.isNumber(count)) {\n    throw new Error(\"RDY count (\" + count + \") is not a number\");\n  }\n  if (!(count >= 0)) {\n    throw new Error(\"RDY count (\" + count + \") is not positive\");\n  }\n  return command('RDY', null, count.toString());\n};\n\nexports.finish = function(id) {\n  if (!(Buffer.byteLength(id) <= 16)) {\n    throw new Error(\"FINISH invalid id (\" + id + \")\");\n  }\n  return command('FIN', null, id);\n};\n\nexports.requeue = function(id, timeMs) {\n  var parameters;\n  if (timeMs == null) {\n    timeMs = 0;\n  }\n  if (!(Buffer.byteLength(id) <= 16)) {\n    throw new Error(\"REQUEUE invalid id (\" + id + \")\");\n  }\n  if (!_.isNumber(timeMs)) {\n    throw new Error(\"REQUEUE delay time is invalid (\" + timeMs + \")\");\n  }\n  parameters = ['REQ', null, id, timeMs];\n  return command.apply(null, parameters);\n};\n\nexports.touch = function(id) {\n  return command('TOUCH', null, id);\n};\n\nexports.nop = function() {\n  return command('NOP', null);\n};\n\nexports.pub = function(topic, data) {\n  return command('PUB', data, topic);\n};\n\nexports.mpub = function(topic, data) {\n  var messages, numMessagesBuffer;\n  if (!_.isArray(data)) {\n    throw new Error(\"MPUB requires an array of message\");\n  }\n  messages = _.map(data, function(message) {\n    var buffer;\n    buffer = new Buffer(4 + byteLength(message));\n    buffer.writeInt32BE(byteLength(message), 0);\n    if (_.isString(message)) {\n      buffer.write(message, 4);\n    } else {\n      message.copy(buffer, 4, 0, buffer.length);\n    }\n    return buffer;\n  });\n  numMessagesBuffer = Buffer(4);\n  numMessagesBuffer.writeInt32BE(messages.length, 0);\n  messages.unshift(numMessagesBuffer);\n  return command('MPUB', Buffer.concat(messages), topic);\n};\n\nexports.auth = function(token) {\n  return command('AUTH', token);\n};\n\nvalidTopicName = function(topic) {\n  var ref;\n  return ((0 < (ref = topic.length) && ref < 65)) && (topic.match(/^[\\w._-]+(?:#ephemeral)?$/) != null);\n};\n\nvalidChannelName = function(channel) {\n  var channelRe, ref;\n  channelRe = /^[\\w._-]+(?:#ephemeral)?$/;\n  return ((0 < (ref = channel.length) && ref < 65)) && (channel.match(channelRe) != null);\n};\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/version.js":"// Generated by CoffeeScript 1.12.5\nmodule.exports = require('../package.json').version;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/reader.js":"// Generated by CoffeeScript 1.12.5\nvar Debug, EventEmitter, NSQDConnection, Reader, ReaderConfig, ReaderRdy, RoundRobinList, _, lookup, request,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\n_ = require('underscore');\n\nDebug = require('debug');\n\nrequest = require('request');\n\nEventEmitter = require('events').EventEmitter;\n\nReaderConfig = require('./config').ReaderConfig;\n\nNSQDConnection = require('./nsqdconnection').NSQDConnection;\n\nReaderRdy = require('./readerrdy').ReaderRdy;\n\nRoundRobinList = require('./roundrobinlist');\n\nlookup = require('./lookupd');\n\nReader = (function(superClass) {\n  extend(Reader, superClass);\n\n  Reader.ERROR = 'error';\n\n  Reader.MESSAGE = 'message';\n\n  Reader.DISCARD = 'discard';\n\n  Reader.NSQD_CONNECTED = 'nsqd_connected';\n\n  Reader.NSQD_CLOSED = 'nsqd_closed';\n\n  function Reader(topic, channel, options) {\n    this.topic = topic;\n    this.channel = channel;\n    this.debug = Debug(\"nsqjs:reader:\" + this.topic + \"/\" + this.channel);\n    this.config = new ReaderConfig(options);\n    this.config.validate();\n    this.debug('Configuration');\n    this.debug(this.config);\n    this.roundrobinLookupd = new RoundRobinList(this.config.lookupdHTTPAddresses);\n    this.readerRdy = new ReaderRdy(this.config.maxInFlight, this.config.maxBackoffDuration, this.topic + \"/\" + this.channel);\n    this.connectIntervalId = null;\n    this.connectionIds = [];\n  }\n\n  Reader.prototype.connect = function() {\n    var delay, delayedStart, directConnect, interval;\n    interval = this.config.lookupdPollInterval * 1000;\n    delay = Math.random() * this.config.lookupdPollJitter * interval;\n    if (this.config.nsqdTCPAddresses.length) {\n      directConnect = (function(_this) {\n        return function() {\n          var addr, address, i, len, port, ref, ref1, results;\n          if (_this.isPaused()) {\n            return;\n          }\n          if (_this.connectionIds.length < _this.config.nsqdTCPAddresses.length) {\n            ref = _this.config.nsqdTCPAddresses;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              addr = ref[i];\n              ref1 = addr.split(':'), address = ref1[0], port = ref1[1];\n              results.push(_this.connectToNSQD(address, Number(port)));\n            }\n            return results;\n          }\n        };\n      })(this);\n      delayedStart = (function(_this) {\n        return function() {\n          return _this.connectIntervalId = setInterval(directConnect.bind(_this), interval);\n        };\n      })(this);\n      directConnect();\n      return setTimeout(delayedStart, delay);\n    } else {\n      delayedStart = (function(_this) {\n        return function() {\n          return _this.connectIntervalId = setInterval(_this.queryLookupd.bind(_this), interval);\n        };\n      })(this);\n      this.queryLookupd();\n      return setTimeout(delayedStart, delay);\n    }\n  };\n\n  Reader.prototype.close = function() {\n    clearInterval(this.connectIntervalId);\n    return this.readerRdy.close();\n  };\n\n  Reader.prototype.pause = function() {\n    this.debug('pause');\n    return this.readerRdy.pause();\n  };\n\n  Reader.prototype.unpause = function() {\n    this.debug('unpause');\n    return this.readerRdy.unpause();\n  };\n\n  Reader.prototype.isPaused = function() {\n    return this.readerRdy.isPaused();\n  };\n\n  Reader.prototype.queryLookupd = function() {\n    var endpoint;\n    if (this.isPaused()) {\n      return;\n    }\n    endpoint = this.roundrobinLookupd.next();\n    return lookup(endpoint, this.topic, (function(_this) {\n      return function(err, nodes) {\n        var i, len, n, results;\n        if (!err) {\n          results = [];\n          for (i = 0, len = nodes.length; i < len; i++) {\n            n = nodes[i];\n            results.push(_this.connectToNSQD(n.broadcast_address, n.tcp_port));\n          }\n          return results;\n        }\n      };\n    })(this));\n  };\n\n  Reader.prototype.connectToNSQD = function(host, port) {\n    var conn;\n    this.debug(\"discovered \" + host + \":\" + port + \" for \" + this.topic + \" topic\");\n    conn = new NSQDConnection(host, port, this.topic, this.channel, this.config);\n    if (this.connectionIds.indexOf(conn.id()) !== -1) {\n      return;\n    }\n    this.debug(\"connecting to \" + host + \":\" + port);\n    this.connectionIds.push(conn.id());\n    this.registerConnectionListeners(conn);\n    this.readerRdy.addConnection(conn);\n    return conn.connect();\n  };\n\n  Reader.prototype.registerConnectionListeners = function(conn) {\n    conn.on(NSQDConnection.CONNECTED, (function(_this) {\n      return function() {\n        _this.debug(Reader.NSQD_CONNECTED);\n        return _this.emit(Reader.NSQD_CONNECTED, conn.nsqdHost, conn.nsqdPort);\n      };\n    })(this));\n    conn.on(NSQDConnection.ERROR, (function(_this) {\n      return function(err) {\n        _this.debug(Reader.ERROR);\n        _this.debug(err);\n        return _this.emit(Reader.ERROR, err);\n      };\n    })(this));\n    conn.on(NSQDConnection.CONNECTION_ERROR, (function(_this) {\n      return function(err) {\n        _this.debug(Reader.ERROR);\n        _this.debug(err);\n        return _this.emit(Reader.ERROR, err);\n      };\n    })(this));\n    conn.on(NSQDConnection.CLOSED, (function(_this) {\n      return function() {\n        var index;\n        _this.debug(Reader.NSQD_CLOSED);\n        index = _this.connectionIds.indexOf(conn.id());\n        if (index === -1) {\n          return;\n        }\n        _this.connectionIds.splice(index, 1);\n        return _this.emit(Reader.NSQD_CLOSED, conn.nsqdHost, conn.nsqdPort);\n      };\n    })(this));\n    return conn.on(NSQDConnection.MESSAGE, (function(_this) {\n      return function(message) {\n        return _this.handleMessage(message);\n      };\n    })(this));\n  };\n\n  Reader.prototype.handleMessage = function(message) {\n    return process.nextTick((function(_this) {\n      return function() {\n        var autoFinishMessage, numDiscardListeners, ref;\n        autoFinishMessage = (0 < (ref = _this.config.maxAttempts) && ref <= message.attempts);\n        numDiscardListeners = _this.listeners(Reader.DISCARD).length;\n        if (autoFinishMessage && numDiscardListeners > 0) {\n          _this.emit(Reader.DISCARD, message);\n        } else {\n          _this.emit(Reader.MESSAGE, message);\n        }\n        if (autoFinishMessage) {\n          return message.finish();\n        }\n      };\n    })(this));\n  };\n\n  return Reader;\n\n})(EventEmitter);\n\nmodule.exports = Reader;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/readerrdy.js":"// Generated by CoffeeScript 1.12.5\nvar BackoffTimer, ConnectionRdy, ConnectionRdyState, Debug, EventEmitter, NSQDConnection, NodeState, READER_COUNT, ReaderRdy, RoundRobinList, _,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\n_ = require('underscore');\n\nDebug = require('debug');\n\nEventEmitter = require('events').EventEmitter;\n\nBackoffTimer = require('./backofftimer');\n\nNodeState = require('node-state');\n\nNSQDConnection = require('./nsqdconnection').NSQDConnection;\n\nRoundRobinList = require('./roundrobinlist');\n\n\n/*\nMaintains the RDY and in-flight counts for a nsqd connection. ConnectionRdy\nensures that the RDY count will not exceed the max set for this connection.\nThe max for the connection can be adjusted at any time.\n\nUsage:\n\nconnRdy = ConnectionRdy conn\nconnRdy.setConnectionRdyMax 10\n\nconn.on 'message', ->\n   * On a successful message, bump up the RDY count for this connection.\n  connRdy.raise 'bump'\nconn.on 'requeue', ->\n   * We're backing off when we encounter a requeue. Wait 5 seconds to try\n   * again.\n  connRdy.raise 'backoff'\n  setTimeout (-> connRdy.raise 'bump'), 5000\n */\n\nConnectionRdy = (function(superClass) {\n  extend(ConnectionRdy, superClass);\n\n  ConnectionRdy.READY = 'ready';\n\n  ConnectionRdy.STATE_CHANGE = 'statechange';\n\n  function ConnectionRdy(conn1) {\n    var connId, readerId;\n    this.conn = conn1;\n    readerId = this.conn.topic + \"/\" + this.conn.channel;\n    connId = \"\" + (this.conn.id().replace(':', '/'));\n    this.debug = Debug(\"nsqjs:reader:\" + readerId + \":rdy:conn:\" + connId);\n    this.maxConnRdy = 0;\n    this.inFlight = 0;\n    this.lastRdySent = 0;\n    this.availableRdy = 0;\n    this.statemachine = new ConnectionRdyState(this);\n    this.conn.on(NSQDConnection.ERROR, (function(_this) {\n      return function(err) {\n        return _this.log(err);\n      };\n    })(this));\n    this.conn.on(NSQDConnection.MESSAGE, (function(_this) {\n      return function() {\n        if (_this.idleId != null) {\n          clearTimeout(_this.idleId);\n        }\n        _this.idleId = null;\n        _this.inFlight += 1;\n        return _this.availableRdy -= 1;\n      };\n    })(this));\n    this.conn.on(NSQDConnection.FINISHED, (function(_this) {\n      return function() {\n        return _this.inFlight -= 1;\n      };\n    })(this));\n    this.conn.on(NSQDConnection.REQUEUED, (function(_this) {\n      return function() {\n        return _this.inFlight -= 1;\n      };\n    })(this));\n    this.conn.on(NSQDConnection.READY, (function(_this) {\n      return function() {\n        return _this.start();\n      };\n    })(this));\n  }\n\n  ConnectionRdy.prototype.close = function() {\n    return this.conn.destroy();\n  };\n\n  ConnectionRdy.prototype.name = function() {\n    return String(this.conn.conn.localPort);\n  };\n\n  ConnectionRdy.prototype.start = function() {\n    this.statemachine.start();\n    return this.emit(ConnectionRdy.READY);\n  };\n\n  ConnectionRdy.prototype.setConnectionRdyMax = function(maxConnRdy) {\n    this.log(\"setConnectionRdyMax \" + maxConnRdy);\n    this.maxConnRdy = Math.min(maxConnRdy, this.conn.maxRdyCount);\n    return this.statemachine.raise('adjustMax');\n  };\n\n  ConnectionRdy.prototype.bump = function() {\n    return this.statemachine.raise('bump');\n  };\n\n  ConnectionRdy.prototype.backoff = function() {\n    return this.statemachine.raise('backoff');\n  };\n\n  ConnectionRdy.prototype.isStarved = function() {\n    if (!(this.inFlight <= this.maxConnRdy)) {\n      throw new Error('isStarved check is failing');\n    }\n    return this.inFlight === this.lastRdySent;\n  };\n\n  ConnectionRdy.prototype.setRdy = function(rdyCount) {\n    this.log(\"RDY \" + rdyCount);\n    if (rdyCount < 0 || rdyCount > this.maxConnRdy) {\n      return;\n    }\n    this.conn.setRdy(rdyCount);\n    return this.availableRdy = this.lastRdySent = rdyCount;\n  };\n\n  ConnectionRdy.prototype.log = function(message) {\n    if (message) {\n      return this.debug(message);\n    }\n  };\n\n  return ConnectionRdy;\n\n})(EventEmitter);\n\nConnectionRdyState = (function(superClass) {\n  extend(ConnectionRdyState, superClass);\n\n  function ConnectionRdyState(connRdy) {\n    this.connRdy = connRdy;\n    ConnectionRdyState.__super__.constructor.call(this, {\n      autostart: false,\n      initial_state: 'INIT',\n      sync_goto: true\n    });\n  }\n\n  ConnectionRdyState.prototype.log = function(message) {\n    this.connRdy.debug(this.current_state_name);\n    if (message) {\n      return this.connRdy.debug(message);\n    }\n  };\n\n  ConnectionRdyState.prototype.states = {\n    INIT: {\n      bump: function() {\n        if (this.connRdy.maxConnRdy > 0) {\n          return this.goto('MAX');\n        }\n      },\n      backoff: function() {},\n      adjustMax: function() {}\n    },\n    BACKOFF: {\n      Enter: function() {\n        return this.connRdy.setRdy(0);\n      },\n      bump: function() {\n        if (this.connRdy.maxConnRdy > 0) {\n          return this.goto('ONE');\n        }\n      },\n      backoff: function() {},\n      adjustMax: function() {}\n    },\n    ONE: {\n      Enter: function() {\n        return this.connRdy.setRdy(1);\n      },\n      bump: function() {\n        return this.goto('MAX');\n      },\n      backoff: function() {\n        return this.goto('BACKOFF');\n      },\n      adjustMax: function() {}\n    },\n    MAX: {\n      Enter: function() {\n        return this.connRdy.setRdy(this.connRdy.maxConnRdy);\n      },\n      bump: function() {\n        var ref, version;\n        version = (ref = this.connRdy.conn) != null ? ref.nsqdVersion : void 0;\n        if (!version || version.split('.') < [0, 3, 0]) {\n          if (this.connRdy.availableRdy <= this.connRdy.lastRdySent * 0.25) {\n            return this.connRdy.setRdy(this.connRdy.maxConnRdy);\n          }\n        }\n      },\n      backoff: function() {\n        return this.goto('BACKOFF');\n      },\n      adjustMax: function() {\n        this.log(\"adjustMax RDY \" + this.connRdy.maxConnRdy);\n        return this.connRdy.setRdy(this.connRdy.maxConnRdy);\n      }\n    }\n  };\n\n  ConnectionRdyState.prototype.transitions = {\n    '*': {\n      '*': function(data, callback) {\n        this.log();\n        callback(data);\n        return this.connRdy.emit(ConnectionRdy.STATE_CHANGE);\n      }\n    }\n  };\n\n  return ConnectionRdyState;\n\n})(NodeState);\n\n\n/*\nUsage:\n\nbackoffTime = 90\nheartbeat = 30\n\n[topic, channel] = ['sample', 'default']\n[host1, port1] = ['127.0.0.1', '4150']\nc1 = new NSQDConnection host1, port1, topic, channel, backoffTime, heartbeat\n\nreaderRdy = new ReaderRdy 1, 128\nreaderRdy.addConnection c1\n\nmessage = (msg) ->\n  console.log \"Callback [message]: #{msg.attempts}, #{msg.body.toString()}\"\n  if msg.attempts >= 5\n    msg.finish()\n    return\n\n  if msg.body.toString() is 'requeue'\n    msg.requeue()\n  else\n    msg.finish()\n\ndiscard = (msg) ->\n  console.log \"Giving up on this message: #{msg.id}\"\n  msg.finish()\n\nc1.on NSQDConnection.MESSAGE, message\nc1.connect()\n */\n\nREADER_COUNT = 0;\n\nReaderRdy = (function(superClass) {\n  extend(ReaderRdy, superClass);\n\n  ReaderRdy.getId = function() {\n    READER_COUNT += 1;\n    return READER_COUNT - 1;\n  };\n\n\n  /*\n  Parameters:\n  - maxInFlight        : Maximum number of messages in-flight across all\n                           connections.\n  - maxBackoffDuration : The longest amount of time (secs) for a backoff event.\n  - readerId           : The descriptive id for the Reader\n  - lowRdyTimeout      : Time (secs) to rebalance RDY count among connections\n                           during low RDY conditions.\n   */\n\n  function ReaderRdy(maxInFlight, maxBackoffDuration, readerId1, lowRdyTimeout) {\n    this.maxInFlight = maxInFlight;\n    this.maxBackoffDuration = maxBackoffDuration;\n    this.readerId = readerId1;\n    this.lowRdyTimeout = lowRdyTimeout != null ? lowRdyTimeout : 1.5;\n    this.debug = Debug(\"nsqjs:reader:\" + this.readerId + \":rdy\");\n    ReaderRdy.__super__.constructor.call(this, {\n      autostart: true,\n      initial_state: 'ZERO',\n      sync_goto: true\n    });\n    this.id = ReaderRdy.getId();\n    this.backoffTimer = new BackoffTimer(0, this.maxBackoffDuration);\n    this.backoffId = null;\n    this.balanceId = null;\n    this.connections = [];\n    this.roundRobinConnections = new RoundRobinList([]);\n  }\n\n  ReaderRdy.prototype.close = function() {\n    var conn, j, len, ref, results;\n    clearTimeout(this.backoffId);\n    clearTimeout(this.balanceId);\n    ref = this.connections;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      conn = ref[j];\n      results.push(conn.close());\n    }\n    return results;\n  };\n\n  ReaderRdy.prototype.pause = function() {\n    return this.raise('pause');\n  };\n\n  ReaderRdy.prototype.unpause = function() {\n    return this.raise('unpause');\n  };\n\n  ReaderRdy.prototype.isPaused = function() {\n    return this.current_state_name === 'PAUSE';\n  };\n\n  ReaderRdy.prototype.log = function(message) {\n    this.debug(this.current_state_name);\n    if (message) {\n      return this.debug(message);\n    }\n  };\n\n  ReaderRdy.prototype.isStarved = function() {\n    var c;\n    if (_.isEmpty(this.connections)) {\n      return false;\n    }\n    return !_.isEmpty(((function() {\n      var j, len, ref, results;\n      if (c.isStarved()) {\n        ref = this.connections;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          c = ref[j];\n          results.push(c);\n        }\n        return results;\n      }\n    }).call(this)));\n  };\n\n  ReaderRdy.prototype.createConnectionRdy = function(conn) {\n    return new ConnectionRdy(conn);\n  };\n\n  ReaderRdy.prototype.isLowRdy = function() {\n    return this.maxInFlight < this.connections.length;\n  };\n\n  ReaderRdy.prototype.onMessageSuccess = function(connectionRdy) {\n    if (!this.isPaused()) {\n      if (this.isLowRdy()) {\n        return this.balance();\n      } else {\n        return connectionRdy.bump();\n      }\n    }\n  };\n\n  ReaderRdy.prototype.addConnection = function(conn) {\n    var connectionRdy;\n    connectionRdy = this.createConnectionRdy(conn);\n    conn.on(NSQDConnection.CLOSED, (function(_this) {\n      return function() {\n        _this.removeConnection(connectionRdy);\n        return _this.balance();\n      };\n    })(this));\n    conn.on(NSQDConnection.FINISHED, (function(_this) {\n      return function() {\n        return _this.raise('success', connectionRdy);\n      };\n    })(this));\n    conn.on(NSQDConnection.REQUEUED, (function(_this) {\n      return function() {\n        if (_this.current_state_name !== 'BACKOFF' && !_this.isPaused()) {\n          return connectionRdy.bump();\n        }\n      };\n    })(this));\n    conn.on(NSQDConnection.BACKOFF, (function(_this) {\n      return function() {\n        return _this.raise('backoff');\n      };\n    })(this));\n    return connectionRdy.on(ConnectionRdy.READY, (function(_this) {\n      return function() {\n        var ref;\n        _this.connections.push(connectionRdy);\n        _this.roundRobinConnections.add(connectionRdy);\n        _this.balance();\n        if (_this.current_state_name === 'ZERO') {\n          return _this.goto('MAX');\n        } else if ((ref = _this.current_state_name) === 'TRY_ONE' || ref === 'MAX') {\n          return connectionRdy.bump();\n        }\n      };\n    })(this));\n  };\n\n  ReaderRdy.prototype.removeConnection = function(conn) {\n    this.connections.splice(this.connections.indexOf(conn), 1);\n    this.roundRobinConnections.remove(conn);\n    if (this.connections.length === 0) {\n      return this.goto('ZERO');\n    }\n  };\n\n  ReaderRdy.prototype.bump = function() {\n    var conn, j, len, ref, results;\n    ref = this.connections;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      conn = ref[j];\n      results.push(conn.bump());\n    }\n    return results;\n  };\n\n  ReaderRdy.prototype[\"try\"] = function() {\n    return this.balance();\n  };\n\n  ReaderRdy.prototype.backoff = function() {\n    var conn, delay, j, len, onTimeout, ref;\n    ref = this.connections;\n    for (j = 0, len = ref.length; j < len; j++) {\n      conn = ref[j];\n      conn.backoff();\n    }\n    if (this.backoffId) {\n      clearTimeout(this.backoffId);\n    }\n    onTimeout = (function(_this) {\n      return function() {\n        _this.log('Backoff done');\n        return _this.raise('try');\n      };\n    })(this);\n    delay = new Number(this.backoffTimer.getInterval().valueOf()) * 1000;\n    this.backoffId = setTimeout(onTimeout, delay);\n    return this.log(\"Backoff for \" + delay);\n  };\n\n  ReaderRdy.prototype.inFlight = function() {\n    var add;\n    add = function(previous, conn) {\n      return previous + conn.inFlight;\n    };\n    return this.connections.reduce(add, 0);\n  };\n\n\n  /*\n  Evenly or fairly distributes RDY count based on the maxInFlight across\n  all nsqd connections.\n   */\n\n  ReaderRdy.prototype.balance = function() {\n\n    /*\n    In the perverse situation where there are more connections than max in\n    flight, we do the following:\n    \n    There is a sliding window where each of the connections gets a RDY count\n    of 1. When the connection has processed it's single message, then the RDY\n    count is distributed to the next waiting connection. If the connection\n    does nothing with it's RDY count, then it should timeout and give it's\n    RDY count to another connection.\n     */\n    var c, connMax, i, j, k, l, len, len1, max, perConnectionMax, rdyRemainder, ref, ref1, ref2, results;\n    this.log('balance');\n    if (this.balanceId != null) {\n      clearTimeout(this.balanceId);\n      this.balanceId = null;\n    }\n    max = (function() {\n      switch (this.current_state_name) {\n        case 'TRY_ONE':\n          return 1;\n        case 'PAUSE':\n          return 0;\n        default:\n          return this.maxInFlight;\n      }\n    }).call(this);\n    perConnectionMax = Math.floor(max / this.connections.length);\n    if (perConnectionMax === 0) {\n      ref = this.connections;\n      for (j = 0, len = ref.length; j < len; j++) {\n        c = ref[j];\n        c.backoff();\n      }\n      ref1 = this.roundRobinConnections.next(max - this.inFlight());\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        c = ref1[k];\n        c.setConnectionRdyMax(1);\n        c.bump();\n      }\n      return this.balanceId = setTimeout(this.balance.bind(this), this.lowRdyTimeout * 1000);\n    } else {\n      rdyRemainder = this.maxInFlight % this.connectionsLength;\n      results = [];\n      for (i = l = 0, ref2 = this.connections.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {\n        connMax = perConnectionMax;\n        if (rdyRemainder > 0) {\n          connMax += 1;\n          rdyRemainder -= 1;\n        }\n        this.connections[i].setConnectionRdyMax(connMax);\n        results.push(this.connections[i].bump());\n      }\n      return results;\n    }\n  };\n\n\n  /*\n  The following events results in transitions in the ReaderRdy state machine:\n  1. Adding the first connection\n  2. Remove the last connections\n  3. Finish event from message handling\n  4. Backoff event from message handling\n  5. Backoff timeout\n   */\n\n  ReaderRdy.prototype.states = {\n    ZERO: {\n      Enter: function() {\n        if (this.backoffId) {\n          return clearTimeout(this.backoffId);\n        }\n      },\n      backoff: function() {},\n      success: function() {},\n      \"try\": function() {},\n      pause: function() {\n        return this.goto('PAUSE');\n      },\n      unpause: function() {}\n    },\n    PAUSE: {\n      Enter: function() {\n        var conn, j, len, ref, results;\n        ref = this.connections;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          conn = ref[j];\n          results.push(conn.backoff());\n        }\n        return results;\n      },\n      backoff: function() {},\n      success: function() {},\n      \"try\": function() {},\n      pause: function() {},\n      unpause: function() {\n        return this.goto('TRY_ONE');\n      }\n    },\n    TRY_ONE: {\n      Enter: function() {\n        return this[\"try\"]();\n      },\n      backoff: function() {\n        return this.goto('BACKOFF');\n      },\n      success: function(connectionRdy) {\n        this.backoffTimer.success();\n        this.onMessageSuccess(connectionRdy);\n        return this.goto('MAX');\n      },\n      \"try\": function() {},\n      pause: function() {\n        return this.goto('PAUSE');\n      },\n      unpause: function() {}\n    },\n    MAX: {\n      Enter: function() {\n        this.balance();\n        return this.bump();\n      },\n      backoff: function() {\n        return this.goto('BACKOFF');\n      },\n      success: function(connectionRdy) {\n        this.backoffTimer.success();\n        return this.onMessageSuccess(connectionRdy);\n      },\n      \"try\": function() {},\n      pause: function() {\n        return this.goto('PAUSE');\n      },\n      unpause: function() {}\n    },\n    BACKOFF: {\n      Enter: function() {\n        this.backoffTimer.failure();\n        return this.backoff();\n      },\n      backoff: function() {\n        this.backoffTimer.failure();\n        return this.backoff();\n      },\n      success: function() {},\n      \"try\": function() {\n        return this.goto('TRY_ONE');\n      },\n      pause: function() {\n        return this.goto('PAUSE');\n      },\n      unpause: function() {}\n    }\n  };\n\n  ReaderRdy.prototype.transitions = {\n    '*': {\n      '*': function(data, callback) {\n        this.log();\n        return callback(data);\n      }\n    }\n  };\n\n  return ReaderRdy;\n\n})(NodeState);\n\nmodule.exports = {\n  ReaderRdy: ReaderRdy,\n  ConnectionRdy: ConnectionRdy\n};\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/backofftimer.js":"// Generated by CoffeeScript 1.12.5\nvar BackoffTimer, decimal, max, min;\n\ndecimal = require('bignumber.js');\n\nmin = function(a, b) {\n  if (a.lte(b)) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\nmax = function(a, b) {\n  if (a.gte(b)) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\n\n/*\nThis is a timer that is smart about backing off exponentially when there\nare problems\n\nPorted from pynsq:\n  https://github.com/bitly/pynsq/blob/master/nsq/BackoffTimer.py\n */\n\nBackoffTimer = (function() {\n  function BackoffTimer(minInterval, maxInterval, ratio, shortLength, longLength) {\n    var intervalDelta;\n    if (ratio == null) {\n      ratio = .25;\n    }\n    if (shortLength == null) {\n      shortLength = 10;\n    }\n    if (longLength == null) {\n      longLength = 250;\n    }\n    this.minInterval = decimal(minInterval);\n    this.maxInterval = decimal(maxInterval);\n    ratio = decimal(ratio);\n    intervalDelta = decimal(this.maxInterval - this.minInterval);\n    this.maxShortTimer = intervalDelta.times(ratio);\n    this.maxLongTimer = intervalDelta.times(decimal(1).minus(ratio));\n    this.shortUnit = this.maxShortTimer.dividedBy(shortLength);\n    this.longUnit = this.maxLongTimer.dividedBy(longLength);\n    this.shortInterval = decimal(0);\n    this.longInterval = decimal(0);\n  }\n\n  BackoffTimer.prototype.success = function() {\n    this.shortInterval = this.shortInterval.minus(this.shortUnit);\n    this.longInterval = this.longInterval.minus(this.longUnit);\n    this.shortInterval = max(this.shortInterval, decimal(0));\n    return this.longInterval = max(this.longInterval, decimal(0));\n  };\n\n  BackoffTimer.prototype.failure = function() {\n    this.shortInterval = this.shortInterval.plus(this.shortUnit);\n    this.longInterval = this.longInterval.plus(this.longUnit);\n    this.shortInterval = min(this.shortInterval, this.maxShortTimer);\n    return this.longInterval = min(this.longInterval, this.maxLongTimer);\n  };\n\n  BackoffTimer.prototype.getInterval = function() {\n    return this.minInterval.plus(this.shortInterval.plus(this.longInterval));\n  };\n\n  return BackoffTimer;\n\n})();\n\nmodule.exports = BackoffTimer;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/roundrobinlist.js":"// Generated by CoffeeScript 1.12.5\n\n/*\nTakes a list and cycles through the elements in the list repeatedly and\nin-order. Adding and removing to the list does not perturb the order.\n\nUsage:\n  lst = RoundRobinList [1, 2, 3]\n  lst.next()                      # Returns [1]\n  lst.next 2                      # Returns [2, 3]\n  lst.next 2                      # Returns [1, 2]\n  lst.add 5\n  lst.next 2                      # Retunrs [3, 5]\n */\nvar RoundRobinList;\n\nRoundRobinList = (function() {\n  function RoundRobinList(lst) {\n    this.lst = lst.slice(0);\n    this.index = 0;\n  }\n\n  RoundRobinList.prototype.length = function() {\n    return this.lst.length;\n  };\n\n  RoundRobinList.prototype.add = function(item) {\n    return this.lst.push(item);\n  };\n\n  RoundRobinList.prototype.remove = function(item) {\n    var itemIndex;\n    itemIndex = this.lst.indexOf(item);\n    if (itemIndex === -1) {\n      return;\n    }\n    if (this.index > itemIndex) {\n      this.index -= 1;\n    }\n    return this.lst.splice(itemIndex, 1);\n  };\n\n  RoundRobinList.prototype.next = function(count) {\n    var index;\n    if (count == null) {\n      count = 1;\n    }\n    index = this.index;\n    this.index = (this.index + count) % this.lst.length;\n    return this.lst.slice(index, index + count);\n  };\n\n  return RoundRobinList;\n\n})();\n\nmodule.exports = RoundRobinList;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/lookupd.js":"// Generated by CoffeeScript 1.12.5\nvar _, async, dedupeOnHostPort, dedupedRequests, lookup, lookupdRequest, request, url;\n\n_ = require('underscore');\n\nasync = require('async');\n\nrequest = require('request');\n\nurl = require('url');\n\n\n/*\nlookupdRequest returns the list of producers from a lookupd given a URL to\nquery.\n\nThe callback will not return an error since it's assumed that there might\nbe transient issues with lookupds.\n */\n\nlookupdRequest = function(url, callback) {\n  var options;\n  options = {\n    url: url,\n    method: 'GET',\n    json: true,\n    timeout: 2000\n  };\n  return request(options, function(err, response, data) {\n    var error, producers, status_code;\n    if (err) {\n      callback(null, []);\n      return;\n    }\n    try {\n      status_code = response.statusCode;\n      producers = data.producers;\n    } catch (error1) {\n      error = error1;\n      callback(null, []);\n      return;\n    }\n    if (status_code !== 200) {\n      callback(null, []);\n      return;\n    }\n    return callback(null, producers);\n  });\n};\n\n\n/*\nTakes a list of responses from lookupds and dedupes the nsqd hosts based on\nhost / port pair.\n\nArguments:\n  results: list of lists of nsqd node objects.\n */\n\ndedupeOnHostPort = function(results) {\n  return _.chain(results).flatten().indexBy(function(item) {\n    return item.broadcast_address + \":\" + item.tcp_port;\n  }).values().value();\n};\n\ndedupedRequests = function(lookupdEndpoints, urlFn, callback) {\n  var endpoint, urls;\n  if (_.isString(lookupdEndpoints)) {\n    lookupdEndpoints = [lookupdEndpoints];\n  }\n  urls = (function() {\n    var i, len, results1;\n    results1 = [];\n    for (i = 0, len = lookupdEndpoints.length; i < len; i++) {\n      endpoint = lookupdEndpoints[i];\n      results1.push(urlFn(endpoint));\n    }\n    return results1;\n  })();\n  return async.map(urls, lookupdRequest, function(err, results) {\n    if (err) {\n      return callback(err, null);\n    } else {\n      return callback(null, dedupeOnHostPort(results));\n    }\n  });\n};\n\n\n/*\nQueries lookupds for known nsqd nodes given a topic and returns a deduped list.\n\nArguments:\n  lookupdEndpoints: a string or a list of strings of lookupd HTTP endpoints. eg.\n    ['127.0.0.1:4161']\n  topic: a string of the topic name.\n  callback: with signature `(err, nodes) ->`. `nodes` is a list of objects\n    return by lookupds and deduped.\n */\n\nlookup = function(lookupdEndpoints, topic, callback) {\n  var endpointURL;\n  endpointURL = function(endpoint) {\n    var parsedUrl;\n    if (endpoint.indexOf('://') === -1) {\n      endpoint = \"http://\" + endpoint;\n    }\n    parsedUrl = url.parse(endpoint, true);\n    if ((!parsedUrl.pathname) || (parsedUrl.pathname === '/')) {\n      parsedUrl.pathname = \"/lookup\";\n    }\n    parsedUrl.query.topic = topic;\n    delete parsedUrl.search;\n    return url.format(parsedUrl);\n  };\n  return dedupedRequests(lookupdEndpoints, endpointURL, callback);\n};\n\nmodule.exports = lookup;\n","/home/travis/build/npmtest/node-npmtest-nsqjs/node_modules/nsqjs/lib/writer.js":"// Generated by CoffeeScript 1.12.5\nvar ConnectionConfig, Debug, EventEmitter, Writer, WriterNSQDConnection, _,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nDebug = require('debug');\n\nEventEmitter = require('events').EventEmitter;\n\n_ = require('underscore');\n\nConnectionConfig = require('./config').ConnectionConfig;\n\nWriterNSQDConnection = require('./nsqdconnection').WriterNSQDConnection;\n\n\n/*\nPublish messages to nsqds.\n\nUsage:\n\nw = new Writer '127.0.0.1', 4150\nw.connect()\n\nw.on Writer.READY, ->\n   * Send a single message\n  w.publish 'sample_topic', 'one'\n   * Send multiple messages\n  w.publish 'sample_topic', ['two', 'three']\nw.on Writer.CLOSED, ->\n  console.log 'Writer closed'\n */\n\nWriter = (function(superClass) {\n  extend(Writer, superClass);\n\n  Writer.READY = 'ready';\n\n  Writer.CLOSED = 'closed';\n\n  Writer.ERROR = 'error';\n\n  function Writer(nsqdHost, nsqdPort, options) {\n    this.nsqdHost = nsqdHost;\n    this.nsqdPort = nsqdPort;\n    Writer.__super__.constructor.apply(this, arguments);\n    this.setMaxListeners(10000);\n    this.debug = Debug(\"nsqjs:writer:\" + this.nsqdHost + \"/\" + this.nsqdPort);\n    this.config = new ConnectionConfig(options);\n    this.config.validate();\n    this.ready = false;\n    this.debug('Configuration');\n    this.debug(this.config);\n  }\n\n  Writer.prototype.connect = function() {\n    this.conn = new WriterNSQDConnection(this.nsqdHost, this.nsqdPort, this.config);\n    this.debug('connect');\n    this.conn.connect();\n    this.conn.on(WriterNSQDConnection.READY, (function(_this) {\n      return function() {\n        _this.debug('ready');\n        _this.ready = true;\n        return _this.emit(Writer.READY);\n      };\n    })(this));\n    this.conn.on(WriterNSQDConnection.CLOSED, (function(_this) {\n      return function() {\n        _this.debug('closed');\n        _this.ready = false;\n        return _this.emit(Writer.CLOSED);\n      };\n    })(this));\n    this.conn.on(WriterNSQDConnection.ERROR, (function(_this) {\n      return function(err) {\n        _this.debug('error', err);\n        _this.ready = false;\n        return _this.emit(Writer.ERROR, err);\n      };\n    })(this));\n    return this.conn.on(WriterNSQDConnection.CONNECTION_ERROR, (function(_this) {\n      return function(err) {\n        _this.debug('error', err);\n        _this.ready = false;\n        return _this.emit(Writer.ERROR, err);\n      };\n    })(this));\n  };\n\n\n  /*\n  Publish a message or a list of messages to the connected nsqd. The contents\n  of the messages should either be strings or buffers with the payload encoded.\n  \n  Arguments:\n    topic: A valid nsqd topic.\n    msgs: A string, a buffer, a JSON serializable object, or\n      a list of string / buffers / JSON serializable objects.\n   */\n\n  Writer.prototype.publish = function(topic, msgs, callback) {\n    var connState, err, failed, msg, ready, ref, ref1, remove;\n    connState = (ref = this.conn) != null ? (ref1 = ref.statemachine) != null ? ref1.current_state_name : void 0 : void 0;\n    if (!this.conn || (connState === 'CLOSED' || connState === 'ERROR')) {\n      err = new Error('No active Writer connection to send messages');\n    }\n    if (!msgs || _.isEmpty(msgs)) {\n      err = new Error('Attempting to publish an empty message');\n    }\n    if (err) {\n      if (callback) {\n        return callback(err);\n      }\n      throw err;\n    }\n    if (!this.ready) {\n      ready = (function(_this) {\n        return function() {\n          remove();\n          return _this.publish(topic, msgs, callback);\n        };\n      })(this);\n      failed = function(err) {\n        err || (err = new Error('Connection closed!'));\n        remove();\n        return callback(err);\n      };\n      remove = (function(_this) {\n        return function() {\n          _this.removeListener(Writer.READY, ready);\n          _this.removeListener(Writer.ERROR, failed);\n          return _this.removeListener(Writer.CLOSED, failed);\n        };\n      })(this);\n      this.on(Writer.READY, ready);\n      this.on(Writer.ERROR, failed);\n      this.on(Writer.CLOSED, failed);\n      return;\n    }\n    if (!_.isArray(msgs)) {\n      msgs = [msgs];\n    }\n    msgs = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = msgs.length; i < len; i++) {\n        msg = msgs[i];\n        if (_.isString(msg) || Buffer.isBuffer(msg)) {\n          results.push(msg);\n        } else {\n          results.push(JSON.stringify(msg));\n        }\n      }\n      return results;\n    })();\n    return this.conn.produceMessages(topic, msgs, callback);\n  };\n\n  Writer.prototype.close = function() {\n    return this.conn.destroy();\n  };\n\n  return Writer;\n\n})(EventEmitter);\n\nmodule.exports = Writer;\n"}